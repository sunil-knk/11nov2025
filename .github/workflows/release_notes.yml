name: Auto Tag and Clean Release Notes (PROD)

on:
  pull_request:
    types: [closed]
    branches:
      - test/PROD

permissions:
  contents: write

jobs:
  create_release:
    if: >
      github.event.pull_request.merged == true &&
      startsWith(github.event.pull_request.title, 'Sprint Release:')
    runs-on: ubuntu-latest

    env:
      TARGET_BRANCH: "test/PROD"
      REPO: ${{ github.repository }}
      API: "https://api.github.com"

    steps:
      # -------------------------------------------------------------
      # 1. Get latest sprint tag
      # -------------------------------------------------------------
      - name: Fetch latest sprint tag from API
        id: tagfetch
        env:
          TOKEN: ${{ secrets.SUNIL3 }}
        run: |
          OWNER=$(echo "${REPO}" | cut -d'/' -f1)
          NAME=$(echo "${REPO}" | cut -d'/' -f2)

          TAGS=$(curl -s -H "Authorization: Bearer ${TOKEN}" \
                "${API}/repos/${OWNER}/${NAME}/tags" \
                | jq -r '.[].name')

          LAST=$(echo "$TAGS" | grep '^sprint_' | sort -V | tail -n1)

          if [ -z "$LAST" ]; then
            NEXT="sprint_1"
          else
            NUM=$(echo "$LAST" | grep -oE '[0-9]+$')
            NEXT="sprint_$((NUM+1))"
          fi

          echo "last_tag=$LAST" >> $GITHUB_OUTPUT
          echo "new_tag=$NEXT" >> $GITHUB_OUTPUT

      # -------------------------------------------------------------
      # 2. Filter PRs: only release/* → test/PROD
      #    Exclude feature → release merges
      # -------------------------------------------------------------
      - name: Collect filtered PRs via REST API
        id: prs
        env:
          TOKEN: ${{ secrets.SUNIL3 }}
        run: |
          OWNER=$(echo "${REPO}" | cut -d'/' -f1)
          NAME=$(echo "${REPO}" | cut -d'/' -f2)

          echo "Fetching merged PRs into ${TARGET_BRANCH}"

          curl -s \
            -H "Authorization: Bearer ${TOKEN}" \
            "${API}/repos/${OWNER}/${NAME}/pulls?state=closed&base=${TARGET_BRANCH}&per_page=100" \
          | jq -r '
              .[]
              | select(.merged_at != null)
              | select(.title | startswith("Sprint Release:"))
              | select(.base.ref == "test/PROD")
              | select(.head.ref | startswith("release/"))
              | "- [#\(.number)](\(.html_url)) \(.title) by @\(.user.login)"
            ' > commits.txt

          if [ ! -s commits.txt ]; then
            echo "No valid PRs for ${TARGET_BRANCH}" > commits.txt
          fi

          echo "Filtered PRs:"
          cat commits.txt

      # -------------------------------------------------------------
      # 3. Create Release with Markdown Notes
      # -------------------------------------------------------------
      - name: Create GitHub Release via REST API
        env:
          TOKEN: ${{ secrets.SUNIL3 }}
          TAG: ${{ steps.tagfetch.outputs.new_tag }}
        run: |
          OWNER=$(echo "${REPO}" | cut -d'/' -f1)
          NAME=$(echo "${REPO}" | cut -d'/' -f2)

          BODY=$(jq -Rs . < commits.txt)

          PAYLOAD=$(jq -n \
            --arg tag "$TAG" \
            --arg target "$TARGET_BRANCH" \
            --arg name "Sprint Release $TAG" \
            --arg body "$BODY" \
            '{
              tag_name:$tag,
              target_commitish:$target,
              name:$name,
              body:$body,
              draft:false,
              prerelease:false
            }')

          curl -s -w "\n%{http_code}" -X POST \
            "${API}/repos/${OWNER}/${NAME}/releases" \
            -H "Authorization: Bearer ${TOKEN}" \
            -H "Content-Type: application/json" \
            -d "$PAYLOAD"
